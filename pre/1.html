<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>1</title>
  <script>const {log, clear} = console;</script>
  <script src="fx.js"></script>
</head>
<body>

1. ES6+ 기본기

- 이터러블
  - 순회 가능한 값.
  - iterable[Symbol.iterator]()로 이터레이터를 리턴하는 값.
<script>
const arr = [1, 2, 3];
// arr[Symbol.iterator] = null;
for (const a of arr) log(a);
</script>

- for...of 가 내부적으로 하는 일
- 이터레이터
  - iterator.next()가 { value: Any, done: Boolean }를 리턴하는 값
<script>
// const iterator = arr[Symbol.iterator]();
// log(iterator.next());
// log(iterator.next());
// log(iterator.next());
// log(iterator.next());

// for (const a of arr) log(a);
const iterator = arr[Symbol.iterator]();
while (true) {
  const { value, done } = iterator.next();
  if (done) break;
  const a = value;
  log(a);
}
</script>

- 제너레이터
  - 실행하면 이터레이터를 반환하는 함수
  - yield 로 next()의 value 값을 발생
  - return 을 하면 { done: true }
<script type="module">
function* gen() {
  log('hi');
  yield 1;
  log('hi2');
  yield 2;
  log('hi3');
  yield 3;
}
const iterator = gen();
log([iterator.next().value, iterator.next().value]);
// log(iterator.next());
// log(iterator.next());
// log(iterator[Symbol.iterator]() == iterator);
// log(iterator.next());
// for (const a of iterator) log(a);
// log(iterator.next());
// log(iterator.next());
// log(iterator.next());
// log(iterator.next());
clear();

function* squares(arr) {
  for (const a of arr) yield a * a;
}
const it = squares([1, 2, 3, 4, 5]);
log(it.next());
log(it.next());
clear();

log( [...squares([1, 2, 3, 4, 5])] );
</script>

2. map, filter
- map
- filter
<script type="module">
const map = function(f, iterable) {
  let res = [];
  for (const a of iterable) {
    res.push(f(a));
  }
  return res;
};
log(map(a => a + 10, [1, 2, 3]));
log(map(a => a.toUpperCase(), ['a', 'b', 'c']));

const filter = function(f, iterable) {
  let res = [];
  for (const a of iterable) {
    if (f(a)) {
      res.push(a);
    }
  }
  return res;
};

log(filter(a => a % 2 == 1, [1, 2, 3, 4, 5]));
log(filter(a => typeof a == 'string', ['aa', 11, {}, 'bb']));
</script>

3. 이터러블 프로토콜로 다시 만들기
- L.map
- L.filter
- toArray
- L.take
- L.takeUntil

<script type="module">
clear();
const L = {};
L.map = function* (f, iterable) {
  for (const a of iterable) {
    yield f(a);
  }
};
L.filter = function* (f, iterable) {
  for (const a of iterable) {
    if (f(a)) yield a;
  }
};

const it = L.map(a => a + 10, [1, 2, 3, 4]);
log(it.next());
log(it.next());

const it2 = L.filter(a => a % 2 == 1, [1, 2, 3, 4, 5]);
log(it2.next());
log(it2.next());
log(it2.next());

log(map(a => a + 10, [1, 2, 3]));

log(filter(a => a % 2 == 1, [1, 2, 3, 4, 5]));
clear();

L.take = function(l, iterable) {
  return L.takeUntil(() => --l == 0, iterable);
};

L.takeUntil = function* (f, iterable) {
  for (const a of iterable) {
    yield a;
    if (f(a)) break;
  }
};

log(toArray(L.take(2, [1, 2, 3, 4, 5, 6])));
log(toArray(L.takeUntil(a => a == 4, [1, 2, 3, 4, 5, 6])));
clear();
</script>

4. 지연 평가와 제너레이터
- range
- 동작 순서와 효율
<script type="module">
const it = L.take(2, L.range(1, 5));
log(it.next());
log(it.next());
log(it.next());
log(it.next());
log(it.next());
clear();

const it2 =
  L.take(Infinity,
    L.filter(a => {
      log('filter', a);
      return a % 2;
    }, L.map(a => {
        log('map', a);
        return a * a;
      }, L.range(1, Infinity))));

log(it2.next());
log(it2.next());
log(it2.next());
clear();
</script>

5. 명령형을 이터러블 프로그래밍으로 전환 1
- 홀수 n개 더하기 명령형 코드
- if를 filter로
- 값 변화 후 변수 할당을 map으로
- break를 take로
- 합산을 reduce로
- 효율 비교

<script type="module">
function f1(limit, iterable) {
  let acc = 0;
  for (let a of iterable) {
    if (a % 2) {
      a = a * a;
      acc = acc + a;
      if (--limit == 0) break;
    }
  }
  log(acc);
}

f1(3, [1, 2, 4, 3, 6, 8, 5, 9, 20, 21, 52, 53]);

const f2 = (limit, iterable) =>
  reduce(add, 0,
    L.take(limit,
      L.map(a => a * a,
        L.filter(a => a % 2, iterable))));

log(f2(3, [1, 2, 4, 3, 6, 8, 5, 9, 20, 21, 52, 53]));
</script>

</body>
</html>